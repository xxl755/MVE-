//// Created by caoqi on 2018/8/31.////3D:  1.36939, -1.17123, 7.04869//obs: 0.180123 -0.156584#include "sfm/bundle_adjustment.h"/* * This function computes the Jacobian entries for the given camera and * 3D point pair that leads to one observation. * * The camera block 'cam_x_ptr' and 'cam_y_ptr' is: * - ID 0: Derivative of focal length f * - ID 1-2: Derivative of distortion parameters k0, k1 * - ID 3-5: Derivative of translation t0, t1, t2 * - ID 6-8: Derivative of rotation w0, w1, w2 * * The 3D point block 'point_x_ptr' and 'point_y_ptr' is: * - ID 0-2: Derivative in x, y, and z direction. * * The function that leads to the observation is given as follows: * *   u = f * D(x,y) * x  (image observation x coordinate) *   v = f * D(x,y) * y  (image observation y coordinate) * * with the following definitions: * *   xc = R0 * X + t0  (homogeneous projection) *   yc = R1 * X + t1  (homogeneous projection) *   zc = R2 * X + t2  (homogeneous projection) *   x = xc / zc  (central projection) *   y = yc / zc  (central projection) *   D(x, y) = 1 + k0 (x^2 + y^2) + k1 (x^2 + y^2)^2  (distortion) */ /**  * /description 给定一个相机参数和一个三维点坐标，求解雅各比矩阵，即公式中的df(theta)/dtheta  * @param cam       相机参数  * @param point     三维点坐标  * @param cam_x_ptr 重投影坐标x 相对于相机参数的偏导数，相机有9个参数： [0] 焦距f; [1-2] 径向畸变系数k1, k2; [3-5] 平移向量 t1, t2, t3  *                                                               [6-8] 旋转矩阵（角轴向量）  * @param cam_y_ptr    重投影坐标y 相对于相机参数的偏导数，相机有9个参数  * @param point_x_ptr  重投影坐标x 相对于三维点坐标的偏导数  * @param point_y_ptr  重投影坐标y 相对于三维点坐标的偏导数  */void jacobian(sfm::ba::Camera const& cam,              sfm::ba::Point3D const& point,              double* cam_x_ptr, double* cam_y_ptr,              double* point_x_ptr, double* point_y_ptr){    const double f = cam.focal_length;    const double *R = cam.rotation;    const double *T = cam.translation;    const double *X = point.pos;    const double k0 = cam.distortion[0];    const double k1 = cam.distortion[1];    //世界点转为归一化坐标系    double zc=R[6]*X[0]+R[7]*X[1]+R[8]*X[2]+T[2];    double xt1=(R[0]*X[0]+R[1]*X[1]+R[2]*X[2]+T[0])/zc;    double yt1=(R[3]*X[0]+R[4]*X[1]+R[5]*X[2]+T[1])/zc;    //成实体像    double rr=std::pow(xt1,2)+std::pow(yt1,2);    double distort=1+k0*rr+k1*rr*rr;    double u=f*distort*xt1;    double v=f*distort*yt1;    // 相机焦距的偏导数,u/v分别对f焦距求偏导    cam_x_ptr[0] = distort*xt1;    cam_y_ptr[0] = distort*yt1;    // 相机径向畸变的偏导数，uv分别对k0，k1求偏导    double u_k0=f*xt1*rr;    double u_k1=f*xt1*rr*rr;    cam_x_ptr[1] = u_k0;    cam_x_ptr[2] = u_k1;    double v_k0=f*yt1*rr;    double v_k1=f*yt1*rr*rr;    cam_y_ptr[1] = v_k0;    cam_y_ptr[2] = v_k1;    //(u,v)=f*distort*(R,T)*(xw,yw,zw),distort=1+k0rr+k1rr^2 求R,T偏导前计算各部分偏导    //归一化坐标系对相机坐标系各参数求导    double xt1_der_xc=1/zc; double xt1_der_yc=0;    double xt1_der_zc=-xt1/zc;    double yt1_der_xc=0;    double yt1_der_yc=1/zc; double yt1_der_zc=-yt1/zc;    //畸变对rr偏导    double distort_der_rr=k0+2*k1*rr;    //rr对归一化像平面求偏导    double rr_der_xt1=2*xt1;    double rr_der_yt1=2*yt1;    //rr对相机坐标系求偏导    double rr_der_xc=rr_der_xt1*xt1_der_xc;    double rr_der_yc=rr_der_yt1*yt1_der_yc;    double rr_der_zc=rr_der_xt1*xt1_der_zc+rr_der_yt1*yt1_der_zc;    //uv对相机坐标系求偏导    double u_der_xc=f*(xt1*distort_der_rr*rr_der_xc+distort*xt1_der_xc);    double u_der_yc=f*(xt1*distort_der_rr*rr_der_yc+distort*xt1_der_yc);    double u_der_zc=f*(xt1*distort_der_rr*rr_der_zc+distort*xt1_der_zc);    double v_der_xc=f*(yt1*distort_der_rr*rr_der_xc+distort*yt1_der_xc);    double v_der_yc=f*(yt1*distort_der_rr*rr_der_yc+distort*yt1_der_yc);    double v_der_zc=f*(yt1*distort_der_rr*rr_der_zc+distort*yt1_der_zc);    //u=1/zc *f*distort*xc,xc=(R00*Xw+R01*Yw+RO2*Zw+t0),    // 其中distort是个套娃（distort内部xy与t有关，直接计算distort对t偏导太复杂0），    // 引入中间变量xc，套娃对xc求偏导(套娃对xc偏导不涉及t)，再利用套娃偏导结果进行链式求导，计算因变量uv对中间变量偏导    double xc_der_t0=1;    double yc_der_t1=1;    double zc_der_t2=1;    // 相机平移向量的偏导数    cam_x_ptr[3] = u_der_xc*xc_der_t0;    cam_x_ptr[4] = u_der_yc*yc_der_t1;    cam_x_ptr[5] = u_der_zc*zc_der_t2;    cam_y_ptr[3] = v_der_xc*xc_der_t0;    cam_y_ptr[4] = v_der_yc*yc_der_t1;    cam_y_ptr[5] = v_der_zc*zc_der_t2;    ;    // 相机旋转矩阵的偏导数，利用罗德里格斯旋转方程，代入微小扰动影响，世界坐标系转相机坐标系时引入扰动，左乘    // (xc,yc,zc)=δR*R*(xw,yw,zw)+T*(xw,yw,zw)    /* 计算关于旋转矩阵(表示为角轴向量w0, w1, w2,旋转矩阵都是正交向量)的偏导数 */    double rx=xt1*zc-T[0];    double ry=yt1*zc-T[1];    double rz=zc-T[2];//中间变量xc，最终变量w，先用相机坐标系对角轴向量求偏导dxc/dw,对每个wi按中间变量连乘求和//如w0偏导： u_der_xc*xc_der_w0+u_der_yc*yc_der_w0+u_der_zc*zc_der_w0；链式求导    double xc_der_w0=0;     double xc_der_w2= -ry;  double xc_der_w1=rz;    double yc_der_w2=rx;    double yc_der_w1=0;     double yc_der_w0=-rz;    double zc_der_w1=-rx;   double zc_der_w0=ry;    double zc_der_w2=0;    cam_x_ptr[6] = u_der_yc*yc_der_w0+u_der_zc*zc_der_w0;    cam_x_ptr[7] = u_der_xc*xc_der_w1+u_der_zc*zc_der_w1;    cam_x_ptr[8] = u_der_xc*xc_der_w2+u_der_yc*yc_der_w2;    cam_y_ptr[6] = v_der_yc*yc_der_w0+v_der_zc*zc_der_w0;    cam_y_ptr[7] = v_der_xc*xc_der_w1+v_der_zc*zc_der_w1;    cam_y_ptr[8] = v_der_xc*xc_der_w2+v_der_yc*yc_der_w2;    // 三维点的偏导数    //中间变量XC对世界坐标X偏导    double xc_der_x=R[0];double xc_der_y=R[1];double xc_der_z=R[2];    double yc_der_x=R[3];double yc_der_y=R[4];double yc_der_z=R[5];    double zc_der_x=R[6];double zc_der_y=R[7];double zc_der_z=R[8];    point_x_ptr[0] = u_der_xc*xc_der_x+u_der_yc*yc_der_x+u_der_zc*zc_der_x;    point_x_ptr[1] = u_der_xc*xc_der_y+u_der_yc*yc_der_y+u_der_zc*zc_der_y;    point_x_ptr[2] = u_der_xc*xc_der_z+u_der_yc*yc_der_z+u_der_zc*zc_der_z;    point_y_ptr[0] = v_der_xc*xc_der_x+v_der_yc*yc_der_x+v_der_zc*zc_der_x;    point_y_ptr[1] = v_der_xc*xc_der_y+v_der_yc*yc_der_y+v_der_zc*zc_der_y;    point_y_ptr[2] = v_der_xc*xc_der_z+v_der_yc*yc_der_z+v_der_zc*zc_der_z;}//一个相机一个三维点计算雅克比矩阵int main(int argc, char*argv[]){    sfm::ba::Camera cam;    cam.focal_length  =  0.919654;    cam.distortion[0] = -0.108298;    cam.distortion[1] =  0.103775;    cam.rotation[0] = 0.999999;    cam.rotation[1] = -0.000676196;    cam.rotation[2] = -0.0013484;    cam.rotation[3] = 0.000663243;    cam.rotation[4] = 0.999949;    cam.rotation[5] = -0.0104095;    cam.rotation[6] = 0.00135482;    cam.rotation[7] = 0.0104087;    cam.rotation[8] = 0.999949;    cam.translation[0]=0.00278292;    cam.translation[1]=0.0587996;    cam.translation[2]=-0.127624;    sfm::ba::Point3D pt3D;    pt3D.pos[0]= 1.36939;    pt3D.pos[1]= -1.17123;    pt3D.pos[2]= 7.04869;    double cam_x_ptr[9]={0};    double cam_y_ptr[9]={0};    double point_x_ptr[3]={0};    double point_y_ptr[3]={0};    jacobian(cam, pt3D, cam_x_ptr, cam_y_ptr, point_x_ptr, point_y_ptr);   std::cout<<"Result is :"<<std::endl;    std::cout<<"cam_x_ptr: ";    for(int i=0; i<9; i++){        std::cout<<cam_x_ptr[i]<<" ";    }    std::cout<<std::endl;    std::cout<<"cam_y_ptr: ";    for(int i=0; i<9; i++){        std::cout<<cam_y_ptr[i]<<" ";    }    std::cout<<std::endl;    std::cout<<"point_x_ptr: ";    std::cout<<point_x_ptr[0]<<" "<<point_x_ptr[1]<<" "<<point_x_ptr[2]<<std::endl;    std::cout<<"point_y_ptr: ";    std::cout<<point_y_ptr[0]<<" "<<point_y_ptr[1]<<" "<<point_y_ptr[2]<<std::endl;    std::cout<<"\nResult should be :\n"       <<"cam_x_ptr: 0.195942 0.0123983 0.000847141 0.131188 0.000847456 -0.0257388 0.0260453 0.95832 0.164303\n"       <<"cam_y_ptr: -0.170272 -0.010774 -0.000736159 0.000847456 0.131426 0.0223669 -0.952795 -0.0244697 0.179883\n"       <<"point_x_ptr: 0.131153 0.000490796 -0.0259232\n"       <<"point_y_ptr: 0.000964926 0.131652 0.0209965\n";    return 0;}